<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>答题闯关</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <link href="css/styles.css" rel="stylesheet">
</head>
  <style>
    /* 全局美化样式 */
    body {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
    }
    
    .glass-effect {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }
    
    .progress-bar {
      height: 1.25rem;
      background: linear-gradient(90deg, #f3f4f6, #e5e7eb);
      border-radius: 9999px;
      overflow: hidden;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
      position: relative;
    }
    
    .progress-bar::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 50%;
      background: linear-gradient(180deg, rgba(255,255,255,0.3), transparent);
      border-radius: 9999px 9999px 0 0;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #667eea, #764ba2, #f093fb);
      width: 1%;
      transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      border-radius: 9999px;
      box-shadow: 0 0 20px rgba(102, 126, 234, 0.4);
    }
    
    .progress-fill::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 50%;
      background: linear-gradient(180deg, rgba(255,255,255,0.4), transparent);
      border-radius: 9999px 9999px 0 0;
    }
    .learning-path {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 2rem 0;
      padding: 2rem;
      background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
      border-radius: 1.5rem;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.2);
    }
    
    .path-node {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0.75rem 0;
      position: relative;
      background: linear-gradient(135deg, #e5e7eb, #d1d5db);
      color: #6B7280;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      border: 3px solid rgba(255, 255, 255, 0.3);
    }
    
    .path-node::before {
      content: '';
      position: absolute;
      top: -3px;
      left: -3px;
      right: -3px;
      bottom: -3px;
      border-radius: 50%;
      background: linear-gradient(135deg, transparent, rgba(255,255,255,0.3));
      z-index: -1;
    }
    
    .path-node.unlocked {
      background: linear-gradient(135deg, #10B981, #059669);
      color: white;
      box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
    }
    
    .path-node.completed {
      background: linear-gradient(135deg, #3B82F6, #2563EB);
      color: white;
      box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4);
    }
    
    .path-node.current {
      background: linear-gradient(135deg, #8B5CF6, #7C3AED);
      color: white;
      transform: scale(1.15);
      box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.3), 0 8px 25px rgba(139, 92, 246, 0.5);
      animation: pulse-glow 2s infinite;
    }
    
    @keyframes pulse-glow {
      0%, 100% { box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.3), 0 8px 25px rgba(139, 92, 246, 0.5); }
      50% { box-shadow: 0 0 0 6px rgba(139, 92, 246, 0.5), 0 8px 30px rgba(139, 92, 246, 0.7); }
    }
    
    .path-node.locked {
      background: linear-gradient(135deg, #9CA3AF, #6B7280);
      cursor: not-allowed;
      opacity: 0.6;
    }
    
    .path-node:hover:not(.locked) {
      transform: scale(1.05);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    }
    .path-connector {
      width: 6px;
      height: 40px;
      background: linear-gradient(to bottom, #e5e7eb, #d1d5db);
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      border-radius: 3px;
      position: relative;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    
    .path-connector::before {
      content: '';
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 2px;
      height: 100%;
      background: linear-gradient(to bottom, rgba(255,255,255,0.6), transparent);
      border-radius: 1px;
    }
    
    .path-connector.active {
      background: linear-gradient(to bottom, #10B981, #059669);
      box-shadow: 0 0 15px rgba(16, 185, 129, 0.4);
    }
    
    .path-connector.excellent {
      background: linear-gradient(to bottom, #10B981, #34D399, #6EE7B7);
      box-shadow: 0 0 20px rgba(16, 185, 129, 0.5);
      animation: shimmer 3s infinite;
    }
    
    .path-connector.good {
      background: linear-gradient(to bottom, #F59E0B, #FBBF24, #FCD34D);
      box-shadow: 0 0 20px rgba(245, 158, 11, 0.5);
    }
    
    .path-connector.needs-improvement {
      background: linear-gradient(to bottom, #EF4444, #F87171, #FCA5A5);
      box-shadow: 0 0 20px rgba(239, 68, 68, 0.5);
    }
    
    @keyframes shimmer {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    .visual-explanation {
      margin-top: 1.5rem;
      padding: 1.5rem;
      border-radius: 1rem;
      background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(147, 197, 253, 0.1));
      border-left: 4px solid #3B82F6;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(59, 130, 246, 0.2);
      box-shadow: 0 8px 32px rgba(59, 130, 246, 0.1);
      transition: all 0.3s ease;
    }
    
    .visual-explanation:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 40px rgba(59, 130, 246, 0.15);
    }
    
    .recommendation-card {
      margin-top: 1rem;
      padding: 1.5rem;
      border-radius: 1rem;
      background: linear-gradient(135deg, rgba(37, 99, 235, 0.1), rgba(59, 130, 246, 0.1));
      border-left: 4px solid #2563EB;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(37, 99, 235, 0.2);
      box-shadow: 0 8px 32px rgba(37, 99, 235, 0.1);
      transition: all 0.3s ease;
    }
    
    .recommendation-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 40px rgba(37, 99, 235, 0.15);
    }
    
    .fade-in {
      animation: fadeIn 0.8s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    @keyframes fadeIn {
      from { 
        opacity: 0;
        transform: translateY(20px);
      }
      to { 
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .slide-in {
      animation: slideIn 0.6s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(-30px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }
    .category-label {
      font-size: 12px;
      color: #374151;
      padding: 6px 12px;
      border-radius: 20px;
      background: linear-gradient(135deg, #F3F4F6, #E5E7EB);
      margin: 0 4px;
      font-weight: 500;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.5);
      transition: all 0.3s ease;
    }
    
    .category-label:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    
    .difficulty-indicator {
      position: absolute;
      bottom: -8px;
      right: -8px;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 3px solid white;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      transition: all 0.3s ease;
    }
    
    .difficulty-indicator:hover {
      transform: scale(1.2);
    }
    
    /* 添加装饰性图标 */
    .icon-decoration {
      display: inline-block;
      margin-right: 8px;
      font-size: 1.2em;
      animation: float 3s ease-in-out infinite;
    }
    
    @keyframes float {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-5px); }
    }
    
    .sparkle {
      position: absolute;
      width: 4px;
      height: 4px;
      background: linear-gradient(45deg, #FFD700, #FFA500);
      border-radius: 50%;
      animation: sparkle 2s infinite;
    }
    
    @keyframes sparkle {
      0%, 100% { opacity: 0; transform: scale(0); }
      50% { opacity: 1; transform: scale(1); }
    }
    
    .sparkle:nth-child(1) { top: 10%; left: 20%; animation-delay: 0s; }
    .sparkle:nth-child(2) { top: 20%; right: 30%; animation-delay: 0.5s; }
    .sparkle:nth-child(3) { bottom: 30%; left: 40%; animation-delay: 1s; }
    .sparkle:nth-child(4) { bottom: 20%; right: 20%; animation-delay: 1.5s; }
    .knowledge-map {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1.5rem;
      margin: 2rem 0;
      padding: 2rem;
      background: linear-gradient(135deg, rgba(249, 250, 251, 0.8), rgba(243, 244, 246, 0.8));
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 1.5rem;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
    }
    
    .knowledge-area {
      padding: 1.5rem;
      border-radius: 1rem;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(248, 250, 252, 0.9));
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.3);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .knowledge-area:hover {
      transform: translateY(-5px);
      box-shadow: 0 15px 45px rgba(0, 0, 0, 0.15);
    }
    
    .mastery-bar {
      height: 12px;
      background: linear-gradient(135deg, #E5E7EB, #D1D5DB);
      border-radius: 6px;
      margin: 0.75rem 0;
      overflow: hidden;
      position: relative;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .mastery-bar::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 50%;
      background: linear-gradient(to bottom, rgba(255,255,255,0.3), transparent);
      border-radius: 6px 6px 0 0;
    }
    
    .mastery-fill {
      height: 100%;
      border-radius: 6px;
      transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
    }
    
    .mastery-fill::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
      animation: shimmer-mastery 2s infinite;
    }
    
    @keyframes shimmer-mastery {
      0% { left: -100%; }
      100% { left: 100%; }
    }
    
    /* 美化按钮样式 */
    .mode-btn {
      position: relative;
      padding: 12px 24px;
      border-radius: 12px;
      font-weight: 600;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      border: none;
      cursor: pointer;
      overflow: hidden;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    }
    
    .mode-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      transition: left 0.5s;
    }
    
    .mode-btn:hover::before {
      left: 100%;
    }
    
    .mode-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    }
    
    .mode-btn:active {
      transform: translateY(0);
    }
    
    .linear-mode {
      background: linear-gradient(135deg, #3B82F6, #1D4ED8);
      color: white;
    }
    
    .adaptive-mode {
      background: linear-gradient(135deg, #8B5CF6, #7C3AED);
      color: white;
    }
    
    .submit-btn, .next-btn, .restart-btn {
      position: relative;
      padding: 12px 32px;
      border-radius: 12px;
      font-weight: 600;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      border: none;
      cursor: pointer;
      overflow: hidden;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    }
    
    .submit-btn {
      background: linear-gradient(135deg, #3B82F6, #1E40AF);
      color: white;
    }
    
    .submit-btn:hover {
      background: linear-gradient(135deg, #2563EB, #1D4ED8);
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(59, 130, 246, 0.3);
    }
    
    .next-btn {
      background: linear-gradient(135deg, #10B981, #059669);
      color: white;
    }
    
    .next-btn:hover {
      background: linear-gradient(135deg, #059669, #047857);
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(16, 185, 129, 0.3);
    }
    
    .restart-btn {
      background: linear-gradient(135deg, #3B82F6, #1E40AF);
      color: white;
    }
    
    .restart-btn:hover {
      background: linear-gradient(135deg, #2563EB, #1D4ED8);
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(59, 130, 246, 0.3);
    }
    
    /* 美化答题卡片 */
    #quiz-card {
      background: linear-gradient(135deg, rgba(255,255,255,0.9), rgba(248,250,252,0.9));
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 1.5rem;
      padding: 2rem;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
      transition: all 0.3s ease;
    }
    
    #quiz-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
    }
    
    /* 美化选项样式 */
    .quiz-option {
      padding: 12px 16px;
      margin: 8px 0;
      border-radius: 12px;
      border: 2px solid #E5E7EB;
      background: linear-gradient(135deg, #FFFFFF, #F9FAFB);
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
    }
    
    .quiz-option::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(59, 130, 246, 0.1), transparent);
      transition: left 0.3s;
    }
    
    .quiz-option:hover::before {
      left: 100%;
    }
    
    .quiz-option:hover {
      border-color: #3B82F6;
      transform: translateX(5px);
      box-shadow: 0 4px 15px rgba(59, 130, 246, 0.2);
    }
    
    .quiz-option.selected {
      border-color: #3B82F6;
      background: linear-gradient(135deg, #EBF4FF, #DBEAFE);
      box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);
    }
    
    /* 美化反馈区域 */
    #feedback {
      border-radius: 1.5rem;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.2);
      transition: all 0.3s ease;
    }
    
    #feedback.correct {
      background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(52, 211, 153, 0.1));
      border-color: rgba(16, 185, 129, 0.3);
    }
    
    #feedback.incorrect {
      background: linear-gradient(135deg, rgba(239, 68, 68, 0.1), rgba(248, 113, 113, 0.1));
      border-color: rgba(239, 68, 68, 0.3);
    }
  </style>
</head>
<body class="bg-gray-50">

    <!-- 导航栏 -->
    <nav class="gradient-bg shadow-lg sticky top-0 z-50">
            <div class="flex justify-between h-16">
                <div class="flex items-center">
                    <div class="flex-shrink-0 flex items-center">
                        <svg class="w-8 h-8 text-white mr-2" fill="currentColor" viewBox="0 0 20 20">
                            <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                        </svg>
                        <span class="text-white text-xl font-bold">GraphLearn</span>
                    </div>
                    <div class="hidden md:block ml-10">
                        <div class="flex space-x-8">
                            <a href="index.html" class="nav-link text-white hover:text-blue-200 px-3 py-2 rounded-md text-sm font-medium">首页</a>
                            <a href="tutorials.html" class="nav-link text-white hover:text-blue-200 px-3 py-2 rounded-md text-sm font-medium">教程</a>
                            <a href="playground.html" class="nav-link text-white hover:text-blue-200 px-3 py-2 rounded-md text-sm font-medium">在线实践</a>
                            <a href="community.html" class="nav-link text-blue-200 px-3 py-2 rounded-md text-sm font-medium">社区</a>
                            <a href="resources.html" class="nav-link text-white hover:text-blue-200 px-3 py-2 rounded-md text-sm font-medium">资源</a>
                            <a href="game.html" class="nav-link text-white hover:text-blue-200 px-3 py-2 rounded-md text-sm font-medium">答题闯关</a>
                            <a href="team.html" class="nav-link text-white hover:text-blue-200 px-3 py-2 rounded-md text-sm font-medium">团队</a>
                        </div>
                    </div>
                </div>
                <div class="flex items-center">
                    <button onclick="toggleLogin()" class="bg-white text-blue-600 px-4 py-2 rounded-md text-sm font-medium hover:bg-blue-50 transition-colors">
                        登录/注册
                    </button>
                </div>
            </div>
        </div>
    </nav>

  <!-- 页面主体 -->
  <main class="max-w-6xl mx-auto mt-8 p-6 bg-white rounded-2xl shadow-md glass-effect" style="position: relative;">
    <!-- 装饰性闪烁元素 -->
    <div class="sparkle"></div>
    <div class="sparkle"></div>
    <div class="sparkle"></div>
    <div class="sparkle"></div>
    
    <!-- 标题 -->
    <h2 class="text-2xl font-bold mb-4 text-center">
      <span class="icon-decoration">🎯</span>
      个性化学习路径闯关
      <span class="icon-decoration">🚀</span>
    </h2>

    <!-- 模式选择 -->
    <div class="flex justify-center mb-6 space-x-4">
      <button id="linear-mode-btn" class="mode-btn linear-mode">
        线性闯关模式
      </button>
      <button id="adaptive-mode-btn" class="mode-btn adaptive-mode">
        个性化学习模式
      </button>
    </div>

    <!-- 用户水平指示器 -->
    <div id="user-level-indicator" class="mb-6 p-4 bg-gradient-to-r from-green-100 to-blue-100 rounded-lg hidden">
      <h3 class="font-semibold mb-2">
        <span class="icon-decoration">📊</span>
        您的当前水平
      </h3>
      <div class="flex items-center">
        <span class="text-sm mr-2">水平等级:</span>
        <div class="flex space-x-1">
          <span id="user-level-stars" class="text-yellow-500"></span>
        </div>
        <span id="user-level-text" class="ml-2 text-sm font-medium"></span>
      </div>
      <div class="mt-2 text-sm text-gray-600" id="level-description"></div>
    </div>

    <!-- 知识掌握情况 -->
    <div id="knowledge-progress" class="mb-6 p-4 bg-gray-50 rounded-lg hidden">
      <h3 class="font-semibold mb-3">
        <span class="icon-decoration">📈</span>
        知识掌握情况
      </h3>
      <div class="knowledge-map">
        <!-- 动态生成知识领域 -->
      </div>
    </div>

    <!-- 关卡进度条 -->
    <div class="mb-6">
      <p class="mb-2">关卡进度：第 <span id="current-level">1</span> 关 / 共 <span id="total-levels">100</span> 关</p>
      <div class="progress-bar">
        <div class="progress-fill" id="progress-fill"></div>
      </div>
    </div>

    <!-- 学习路径地图 -->
    <div id="learning-path-container" class="hidden">
      <h3 class="text-lg font-semibold mb-4 text-center">
        <span class="icon-decoration">🗺️</span>
        您的个性化学习路径
        <span class="icon-decoration">✨</span>
      </h3>
      <div class="learning-path">
        <!-- 动态生成学习路径 -->
      </div>
    </div>

    <!-- 答题卡 -->
    <section id="quiz-card" class="mb-6">
      <div class="flex justify-between items-center mb-3">
        <h3 id="question-text" class="text-lg font-semibold">题目加载中...</h3>
        <div class="flex items-center">
          <span class="category-label" id="question-category"></span>
          <span class="difficulty-indicator ml-2" id="question-difficulty"></span>
        </div>
      </div>
      <form id="quiz-form" class="space-y-3"></form>
    </section>

    <!-- 提交按钮 -->
    <div class="text-center">
      <button id="submit-btn" class="submit-btn">
        提交答案
      </button>
    </div>

    <!-- 答案反馈 -->
    <div id="feedback" class="mt-4 p-4 rounded-lg hidden">
      <h4 class="font-semibold mb-2" id="feedback-title"></h4>
      <p id="feedback-content" class="mb-3"></p>
      
      <!-- 可视化解释 -->
      <div id="visual-explanation" class="visual-explanation hidden">
        <h5 class="font-semibold mb-2">📊 可视化解释</h5>
        <div id="explanation-content"></div>
      </div>
      
      <!-- 学习资源推荐 -->
      <div id="resource-recommendation" class="recommendation-card hidden">
        <h5 class="font-semibold mb-2">📚 推荐学习资源</h5>
        <ul id="resource-list" class="list-disc pl-5"></ul>
      </div>
    </div>

    <!-- 下一关按钮 -->
    <div class="text-center mt-4 hidden" id="next-level-container">
      <button id="next-level-btn" class="next-btn">
        进入下一关
      </button>
    </div>

    <!-- 通关庆祝 -->
    <div id="completion-celebration" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
      <div class="bg-white p-8 rounded-2xl text-center max-w-md">
        <div class="text-6xl mb-4">🎉</div>
        <h3 class="text-2xl font-bold mb-4">恭喜通关！</h3>
        <p class="mb-4">您已成功完成个性化学习路径！</p>
        <p class="text-lg font-semibold mb-4">最终得分: <span id="final-score">0</span></p>
        <button id="restart-btn" class="restart-btn">
          重新开始
        </button>
      </div>
    </div>
  </main>

  <!-- JS 脚本 -->
  <script>
    // 题库数据 - 扩展更多题目
    const questions = [
      // 基础概念类
      {id: 1, question:"以下哪种是最经典的图神经网络模型？",options:["CNN","GCN","RNN","LSTM"],answer:1, category:"基础概念", difficulty:1,
       explanation:"GCN（图卷积网络）是最经典的图神经网络模型，专门用于处理图结构数据。",
       resources:["教程：GCN基本原理","视频：图卷积网络详解"], prerequisites: []},
      
      {id: 2, question:"GCN 最常用于处理哪类数据？",options:["图结构数据","序列数据","图像数据","表格数据"],answer:0, category:"基础概念", difficulty:1,
       explanation:"GCN专门设计用于处理图结构数据，能够有效捕捉节点之间的关系。",
       resources:["文章：图数据结构入门","教程：GCN应用场景"], prerequisites: [1]},
      
      {id: 3, question:"在图中，节点之间通过什么表示关系？",options:["边","权重","标签","矩阵"],answer:0, category:"基础概念", difficulty:1,
       explanation:"图中的节点通过边(edge)来表示彼此之间的关系。",
       resources:["教程：图论基础","视频：图的表示方法"], prerequisites: [1]},
      
      // 模型架构类
      {id: 4, question:"Graph Attention Network (GAT) 引入了什么机制？",options:["卷积","注意力机制","循环","强化学习"],answer:1, category:"模型架构", difficulty:2,
       explanation:"GAT引入了注意力机制，使模型能够为不同的邻居节点分配不同的重要性权重。",
       resources:["论文：Graph Attention Networks","教程：注意力机制在图神经网络中的应用"], prerequisites: [1,2]},
      
      {id: 5, question:"GraphSAGE 模型的核心思想是？",options:["基于采样的节点聚合","全局特征编码","序列生成","边预测"],answer:0, category:"模型架构", difficulty:2,
       explanation:"GraphSAGE通过采样和聚合邻居节点的特征来生成节点嵌入，适用于大规模图数据。",
       resources:["论文：Inductive Representation Learning on Large Graphs","教程：GraphSAGE原理与应用"], prerequisites: [1,2]},
      
      // 应用场景类
      {id: 6, question:"GNN 在推荐系统中可用于？",options:["社交推荐","协同过滤","内容推荐","以上都可以"],answer:3, category:"应用场景", difficulty:2,
       explanation:"图神经网络在推荐系统中有广泛应用，包括社交推荐、协同过滤和内容推荐等场景。",
       resources:["案例：GNN在推荐系统中的应用","教程：构建图神经网络推荐系统"], prerequisites: [1,2]},
      
      // 高级主题类
      {id: 7, question:"动态图神经网络主要用于处理什么类型的图？",options:["静态图","随时间变化的图","大规模图","异构图"],answer:1, category:"高级主题", difficulty:3,
       explanation:"动态图神经网络专门设计用于处理随时间变化的图结构，如演化的社交网络或交易网络。",
       resources:["论文：动态GNN综述","教程：动态图表示学习"], prerequisites: [4,5]},
      
      {id: 8, question:"异构图神经网络与传统GNN的主要区别是什么？",options:["处理多种类型节点和边","计算效率更高","只能处理小规模图","不需要特征提取"],answer:0, category:"高级主题", difficulty:3,
       explanation:"异构图神经网络专门设计处理包含多种类型节点和边的异质信息图。",
       resources:["论文：异质图神经网络","教程：HetGNN详解"], prerequisites: [4,5]},
      
      // 实践技巧类
      {id: 9, question:"图神经网络训练中过度平滑问题是指什么？",options:["训练速度过快","所有节点表示变得相似","梯度爆炸","损失函数不收敛"],answer:1, category:"实践技巧", difficulty:3,
       explanation:"过度平滑问题是指当GNN层数过深时，所有节点的表示会趋于相似，丢失区分度。",
       resources:["教程：解决过度平滑问题","论文：GNN深度限制"], prerequisites: [4,5,6]},
      
      {id: 10, question:"以下哪种技术不能解决GNN的过度平滑问题？",options:["残差连接","跳跃连接","增加更多层数","图归一化"],answer:2, category:"实践技巧", difficulty:3,
       explanation:"增加更多层数会加剧过度平滑问题，而不是解决它。",
       resources:["教程：GNN最佳实践","论文：GNN架构优化"], prerequisites: [9]}
    ];

    // 知识图谱结构
    const knowledgeGraph = {
      "基础概念": { prerequisites: [], color: "#3B82F6", description: "图神经网络的基本概念和术语" },
      "模型架构": { prerequisites: ["基础概念"], color: "#10B981", description: "各种GNN模型的结构和原理" },
      "应用场景": { prerequisites: ["基础概念"], color: "#F59E0B", description: "GNN在不同领域的应用案例" },
      "高级主题": { prerequisites: ["模型架构", "应用场景"], color: "#8B5CF6", description: "GNN的前沿研究和高级主题" },
      "实践技巧": { prerequisites: ["模型架构", "应用场景"], color: "#EC4899", description: "GNN训练和优化的实用技巧" }
    };

    // 用户学习状态
    const userState = {
      currentLevel: 0,
      score: 0,
      masteryLevel: 0, // 0-新手, 1-初级, 2-中级, 3-高级
      masteredCategories: {},
      weakCategories: {},
      answeredQuestions: new Set(),
      unlockedQuestions: new Set([1]), // 初始解锁第一题
      adaptiveMode: true,
      learningPath: [],
      selectedAnswer: null,
      currentQuestionIndex: 0
    };

    // DOM元素
    const questionText = document.getElementById("question-text");
    const quizForm = document.getElementById("quiz-form");
    const feedback = document.getElementById("feedback");
    const feedbackTitle = document.getElementById("feedback-title");
    const feedbackContent = document.getElementById("feedback-content");
    const progressFill = document.getElementById("progress-fill");
    const currentLevelSpan = document.getElementById("current-level");
    const totalLevelsSpan = document.getElementById("total-levels");
    const submitBtn = document.getElementById("submit-btn");
    const nextLevelBtn = document.getElementById("next-level-btn");
    const nextLevelContainer = document.getElementById("next-level-container");
    const visualExplanation = document.getElementById("visual-explanation");
    const explanationContent = document.getElementById("explanation-content");
    const resourceRecommendation = document.getElementById("resource-recommendation");
    const resourceList = document.getElementById("resource-list");
    const linearModeBtn = document.getElementById("linear-mode-btn");
    const adaptiveModeBtn = document.getElementById("adaptive-mode-btn");
    const learningPathContainer = document.getElementById("learning-path-container");
    const userLevelIndicator = document.getElementById("user-level-indicator");
    const knowledgeProgress = document.getElementById("knowledge-progress");
    const questionCategory = document.getElementById("question-category");
    const questionDifficulty = document.getElementById("question-difficulty");
    const completionCelebration = document.getElementById("completion-celebration");
    const finalScore = document.getElementById("final-score");
    const restartBtn = document.getElementById("restart-btn");
    const userLevelStars = document.getElementById("user-level-stars");
    const userLevelText = document.getElementById("user-level-text");
    const levelDescription = document.getElementById("level-description");

    // 初始化
    totalLevelsSpan.textContent = questions.length;
    
    // 模式选择事件
    linearModeBtn.addEventListener("click", () => {
      userState.adaptiveMode = false;
      linearModeBtn.classList.add("bg-blue-700");
      adaptiveModeBtn.classList.remove("bg-purple-700");
      adaptiveModeBtn.classList.add("bg-purple-600");
      learningPathContainer.classList.add("hidden");
      userLevelIndicator.classList.add("hidden");
      knowledgeProgress.classList.add("hidden");
      resetProgress();
    });
    
    adaptiveModeBtn.addEventListener("click", () => {
      userState.adaptiveMode = true;
      adaptiveModeBtn.classList.add("bg-purple-700");
      linearModeBtn.classList.remove("bg-blue-700");
      linearModeBtn.classList.add("bg-blue-600");
      learningPathContainer.classList.remove("hidden");
      userLevelIndicator.classList.remove("hidden");
      knowledgeProgress.classList.remove("hidden");
      generateLearningPath();
      updateUserLevelIndicator();
      updateKnowledgeProgress();
      resetProgress();
    });

    // 生成个性化学习路径
    function generateLearningPath() {
      // 1. 确定用户当前水平
      const userLevel = calculateUserLevel();
      userState.masteryLevel = userLevel;
      
      // 2. 确定需要加强的知识领域
      const weakAreas = identifyWeakAreas();
      
      // 3. 获取可用的题目（已解锁且符合先决条件）
      const availableQuestions = questions.filter(q => 
        userState.unlockedQuestions.has(q.id) && 
        q.prerequisites.every(preq => userState.answeredQuestions.has(preq))
      );
      
      // 4. 构建学习路径
      userState.learningPath = [];
      
      // 优先处理薄弱领域
      weakAreas.forEach(area => {
        const areaQuestions = availableQuestions.filter(q => 
          q.category === area && !userState.answeredQuestions.has(q.id)
        );
        
        if (areaQuestions.length > 0) {
          // 选择适当难度的问题
          const selectedQuestions = selectQuestionsForCategory(areaQuestions, userLevel);
          selectedQuestions.forEach(q => {
            userState.learningPath.push({
              id: userState.learningPath.length,
              questionId: q.id,
              category: q.category,
              difficulty: q.difficulty
            });
          });
        }
      });
      
      // 添加其他可用题目
      const otherQuestions = availableQuestions.filter(q => 
        !weakAreas.includes(q.category) && 
        !userState.answeredQuestions.has(q.id)
      );
      
      if (otherQuestions.length > 0) {
        const selectedQuestions = selectQuestionsForCategory(otherQuestions, userLevel);
        selectedQuestions.forEach(q => {
          userState.learningPath.push({
            id: userState.learningPath.length,
            questionId: q.id,
            category: q.category,
            difficulty: q.difficulty
          });
        });
      }
      
      // 如果路径为空，重新评估并生成
      if (userState.learningPath.length === 0) {
        reevaluateUnlockedQuestions();
        generateLearningPath();
        return;
      }
      
      // 更新UI
      updateLearningPathUI();
      updateUserLevelIndicator();
      updateKnowledgeProgress();
    }

    // 计算用户当前水平
    function calculateUserLevel() {
      if (userState.answeredQuestions.size === 0) return 0;
      
      let correctCount = 0;
      let totalDifficulty = 0;
      
      userState.answeredQuestions.forEach(questionId => {
        const question = questions.find(q => q.id === questionId);
        if (question && userState.selectedAnswer === question.answer) {
          correctCount++;
        }
        if (question) {
          totalDifficulty += question.difficulty;
        }
      });
      
      const accuracy = correctCount / userState.answeredQuestions.size;
      const averageDifficulty = totalDifficulty / userState.answeredQuestions.size;
      
      if (accuracy > 0.8 && averageDifficulty > 2.5) return 3; // 高级
      if (accuracy > 0.7 && averageDifficulty > 2) return 2;   // 中级
      if (accuracy > 0.6) return 1;                            // 初级
      return 0;                                                // 新手
    }

    // 识别用户薄弱领域
    function identifyWeakAreas() {
      const weakAreas = [];
      const categoryStats = {};
      
      // 初始化统计
      Object.keys(knowledgeGraph).forEach(category => {
        categoryStats[category] = { correct: 0, total: 0 };
      });
      
      // 统计每个类别的答题情况
      userState.answeredQuestions.forEach(questionId => {
        const question = questions.find(q => q.id === questionId);
        if (question) {
          categoryStats[question.category].total++;
          if (userState.selectedAnswer === question.answer) {
            categoryStats[question.category].correct++;
          }
        }
      });
      
      // 找出准确率低于阈值的类别
      for (const [category, stats] of Object.entries(categoryStats)) {
        if (stats.total > 2 && stats.correct / stats.total < 0.6) {
          weakAreas.push(category);
        }
      }
      
      return weakAreas.length > 0 ? weakAreas : Object.keys(knowledgeGraph);
    }

    // 为特定类别选择问题
    function selectQuestionsForCategory(questions, userLevel) {
      let targetDifficulty, count;
      
      switch(userLevel) {
        case 0: // 新手
          targetDifficulty = 1; count = 2; break;
        case 1: // 初级
          targetDifficulty = 1.5; count = 3; break;
        case 2: // 中级
          targetDifficulty = 2; count = 3; break;
        case 3: // 高级
          targetDifficulty = 2.5; count = 4; break;
        default:
          targetDifficulty = 1.5; count = 3;
      }
      
      return questions
        .sort((a, b) => Math.abs(a.difficulty - targetDifficulty) - Math.abs(b.difficulty - targetDifficulty))
        .slice(0, Math.min(count, questions.length));
    }

    // 重新评估已解锁的题目
    function reevaluateUnlockedQuestions() {
      // 根据用户水平解锁新题目
      const newUnlocked = [];
      
      questions.forEach(question => {
        if (!userState.unlockedQuestions.has(question.id)) {
          // 检查是否满足解锁条件
          const canUnlock = question.prerequisites.every(preq => 
            userState.answeredQuestions.has(preq)
          ) && question.difficulty <= userState.masteryLevel + 1;
          
          if (canUnlock) {
            newUnlocked.push(question.id);
          }
        }
      });
      
      newUnlocked.forEach(id => userState.unlockedQuestions.add(id));
      
      if (newUnlocked.length > 0) {
        // 显示解锁通知
        showUnlockNotification(newUnlocked);
      }
    }

    // 显示解锁通知
    function showUnlockNotification(unlockedIds) {
      const unlockedQuestions = questions.filter(q => unlockedIds.includes(q.id));
      const notification = document.createElement("div");
      notification.className = "fixed top-4 right-4 bg-white p-4 rounded-lg shadow-lg border-l-4 border-green-500 z-50";
      notification.innerHTML = `
        <h4 class="font-semibold mb-2">🎯 新关卡解锁！</h4>
        <p class="text-sm mb-2">您已解锁 ${unlockedIds.length} 个新题目：</p>
        <ul class="text-xs list-disc list-inside">
          ${unlockedQuestions.map(q => `<li>${q.category} - ${q.question.substring(0, 30)}...</li>`).join('')}
        </ul>
      `;
      
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.remove();
      }, 5000);
    }

    // 更新学习路径UI
    function updateLearningPathUI() {
      const pathContainer = document.querySelector(".learning-path");
      if (!pathContainer) return;
      
      pathContainer.innerHTML = "";
      
      userState.learningPath.forEach((node, index) => {
        const question = questions.find(q => q.id === node.questionId);
        if (!question) return;
        
        const nodeEl = document.createElement("div");
        nodeEl.className = "path-node";
        nodeEl.innerHTML = index + 1;
        nodeEl.setAttribute("data-id", question.id);
        nodeEl.setAttribute("data-category", question.category);
        
        // 设置节点状态
        if (index < userState.currentLevel) {
          nodeEl.classList.add("completed");
          const isCorrect = userState.answeredQuestions.has(question.id) && 
            userState.selectedAnswer === question.answer;
          nodeEl.classList.add(isCorrect ? "correct" : "incorrect");
        } else if (index === userState.currentLevel) {
          nodeEl.classList.add("current");
        } else {
          nodeEl.classList.add("locked");
        }
        
        // 添加难度指示器
        const difficultyIndicator = document.createElement("div");
        difficultyIndicator.className = "difficulty-indicator";
        difficultyIndicator.style.backgroundColor = 
          question.difficulty === 1 ? '#10B981' : 
          question.difficulty === 2 ? '#F59E0B' : '#EF4444';
        nodeEl.appendChild(difficultyIndicator);
        
        pathContainer.appendChild(nodeEl);
        
        // 添加连接线
        if (index < userState.learningPath.length - 1) {
          const connector = document.createElement("div");
          connector.className = "path-connector";
          if (index < userState.currentLevel) {
            connector.classList.add("active");
          }
          pathContainer.appendChild(connector);
        }
      });
    }

    // 更新用户水平指示器
    function updateUserLevelIndicator() {
      const levels = ["新手", "初级", "中级", "高级"];
      const descriptions = [
        "刚开始学习图神经网络，建议从基础概念开始",
        "已掌握基础知识，可以尝试更复杂的模型架构",
        "对GNN有较好理解，可以挑战高级主题和应用",
        "GNN专家水平，可以深入研究前沿技术和实践技巧"
      ];
      
      userLevelStars.innerHTML = "★".repeat(userState.masteryLevel + 1);
      userLevelText.textContent = levels[userState.masteryLevel];
      levelDescription.textContent = descriptions[userState.masteryLevel];
    }

    // 更新知识掌握进度
    function updateKnowledgeProgress() {
      const container = document.querySelector(".knowledge-map");
      if (!container) return;
      
      container.innerHTML = "";
      
      Object.entries(knowledgeGraph).forEach(([category, info]) => {
        const stats = calculateCategoryStats(category);
        const masteryPercent = stats.total > 0 ? (stats.correct / stats.total) * 100 : 0;
        
        const areaEl = document.createElement("div");
        areaEl.className = "knowledge-area";
        areaEl.innerHTML = `
          <h4 class="font-semibold mb-2">${category}</h4>
          <p class="text-xs text-gray-600 mb-2">${info.description}</p>
          <div class="mastery-bar">
            <div class="mastery-fill" style="width: ${masteryPercent}%; background: ${info.color};"></div>
          </div>
          <div class="flex justify-between text-xs">
            <span>掌握度: ${Math.round(masteryPercent)}%</span>
            <span>${stats.correct}/${stats.total}</span>
          </div>
        `;
        
        container.appendChild(areaEl);
      });
    }

    // 计算类别统计
    function calculateCategoryStats(category) {
      let correct = 0, total = 0;
      
      userState.answeredQuestions.forEach(questionId => {
        const question = questions.find(q => q.id === questionId);
        if (question && question.category === category) {
          total++;
          if (userState.selectedAnswer === question.answer) {
            correct++;
          }
        }
      });
      
      return { correct, total };
    }

    // 选择题目
    function selectQuestion() {
      if (!userState.adaptiveMode) {
        return userState.currentLevel % questions.length;
      }
      
      if (userState.learningPath.length > 0 && userState.currentLevel < userState.learningPath.length) {
        const pathNode = userState.learningPath[userState.currentLevel];
        return questions.findIndex(q => q.id === pathNode.questionId);
      }
      
      return 0;
    }

    // 加载题目
    function loadQuestion() {
      userState.currentQuestionIndex = selectQuestion();
      const q = questions[userState.currentQuestionIndex];
      
      if (!q) return;
      
      questionText.textContent = q.question;
      questionCategory.textContent = q.category;
      questionDifficulty.style.backgroundColor = 
        q.difficulty === 1 ? '#10B981' : 
        q.difficulty === 2 ? '#F59E0B' : '#EF4444';
      
      quizForm.innerHTML = "";
      q.options.forEach((opt, i) => {
        const label = document.createElement("label");
        label.className = "flex items-center space-x-2 p-2 rounded hover:bg-gray-100 cursor-pointer";
        label.innerHTML = `<input type="radio" name="answer" value="${i}" class="text-blue-600"> <span>${opt}</span>`;
        quizForm.appendChild(label);
      });
      
      // 重置UI状态
      feedback.classList.add("hidden");
      nextLevelContainer.classList.add("hidden");
      visualExplanation.classList.add("hidden");
      resourceRecommendation.classList.add("hidden");
      userState.selectedAnswer = null;
    }

    // 提交答案
    submitBtn.addEventListener("click", () => {
      const selectedOption = document.querySelector("input[name='answer']:checked");
      if (!selectedOption) {
        alert("请选择一个答案！");
        return;
      }
      
      const answer = parseInt(selectedOption.value);
      userState.selectedAnswer = answer;
      const currentQuestion = questions[userState.currentQuestionIndex];
      const isCorrect = answer === currentQuestion.answer;
      
      // 更新用户状态
      userState.answeredQuestions.add(currentQuestion.id);
      
      if (isCorrect) {
        userState.score += currentQuestion.difficulty * 10;
        // 解锁相关题目
        unlockRelatedQuestions(currentQuestion.id);
      }
      
      // 显示反馈
      showFeedback(isCorrect, currentQuestion);
      
      // 更新UI
      updateProgressDisplay();
      updateUserLevelIndicator();
      updateKnowledgeProgress();
    });

    // 解锁相关题目
    function unlockRelatedQuestions(questionId) {
      const relatedQuestions = questions.filter(q => 
        q.prerequisites.includes(questionId) && 
        !userState.unlockedQuestions.has(q.id)
      );
      
      relatedQuestions.forEach(q => {
        userState.unlockedQuestions.add(q.id);
      });
      
      if (relatedQuestions.length > 0) {
        showUnlockNotification(relatedQuestions.map(q => q.id));
      }
    }

    // 显示反馈
    function showFeedback(isCorrect, question) {
      feedback.classList.remove("hidden");
      
      if (isCorrect) {
        feedbackTitle.textContent = "✓ 回答正确！";
        feedbackTitle.className = "font-semibold mb-2 text-green-600";
      } else {
        feedbackTitle.textContent = "✗ 回答错误";
        feedbackTitle.className = "font-semibold mb-2 text-red-600";
      }
      
      feedbackContent.innerHTML = isCorrect ? 
        question.explanation : 
        `<p>正确答案是：${question.options[question.answer]}</p><p class="mt-2">${question.explanation}</p>`;
      
      // 显示解释和资源
      explanationContent.textContent = getVisualExplanation(question);
      resourceList.innerHTML = "";
      question.resources.forEach(resource => {
        const li = document.createElement("li");
        li.textContent = resource;
        resourceList.appendChild(li);
      });
      
      visualExplanation.classList.remove("hidden");
      resourceRecommendation.classList.remove("hidden");
      nextLevelContainer.classList.remove("hidden");
    }

    // 获取可视化解释
    function getVisualExplanation(question) {
      const explanations = {
        "基础概念": "这是图神经网络的基础知识，建议牢固掌握。",
        "模型架构": "理解模型架构有助于选择合适的方法解决问题。",
        "应用场景": "了解应用场景可以帮助您在实际项目中更好地运用GNN。",
        "高级主题": "这些是GNN的前沿研究方向，适合深入学习。",
        "实践技巧": "实用技巧可以帮助您更有效地训练和优化模型。"
      };
      return explanations[question.category] || "这是一个重要的GNN知识点。";
    }

    // 下一关
    nextLevelBtn.addEventListener("click", () => {
      if (userState.adaptiveMode) {
        userState.currentLevel++;
        
        // 检查是否需要生成新的学习路径
        if (userState.currentLevel >= userState.learningPath.length) {
          // 完成当前路径，生成新路径
          generateLearningPath();
          
          // 检查是否所有题目都已完成
          if (userState.answeredQuestions.size >= questions.length * 0.8) {
            showCompletionCelebration();
            return;
          }
          
          // 重置当前路径中的位置，但保持总体进度
          userState.currentLevel = 0;
        }
        
        // 更新进度条：基于总答题数而不是当前路径位置
        const totalAnswered = userState.answeredQuestions.size;
        const progressPercent = Math.min((totalAnswered / questions.length) * 100, 100);
        
        currentLevelSpan.textContent = totalAnswered + 1;
        progressFill.style.width = progressPercent + "%";
        
        updateLearningPathUI();
      } else {
        userState.currentLevel++;
        if (userState.currentLevel >= questions.length) {
          userState.currentLevel = 0;
        }
        
        currentLevelSpan.textContent = userState.currentLevel + 1;
        progressFill.style.width = ((userState.currentLevel + 1) / questions.length * 100) + "%";
      }
      
      loadQuestion();
    });

    // 显示通关庆祝
    function showCompletionCelebration() {
      finalScore.textContent = userState.score;
      completionCelebration.classList.remove("hidden");
    }

    // 重新开始
    restartBtn.addEventListener("click", () => {
      completionCelebration.classList.add("hidden");
      resetProgress();
    });

    // 重置进度
    function resetProgress() {
      userState.currentLevel = 0;
      userState.score = 0;
      userState.masteryLevel = 0;
      userState.masteredCategories = {};
      userState.weakCategories = {};
      userState.answeredQuestions.clear();
      userState.unlockedQuestions.clear();
      userState.unlockedQuestions.add(1);
      userState.learningPath = [];
      userState.selectedAnswer = null;
      
      // 更新进度显示
      updateProgressDisplay();
      
      if (userState.adaptiveMode) {
        generateLearningPath();
        updateUserLevelIndicator();
        updateKnowledgeProgress();
      }
      
      loadQuestion();
    }
    
    // 更新进度显示
    function updateProgressDisplay() {
      if (userState.adaptiveMode) {
        const totalAnswered = userState.answeredQuestions.size;
        const progressPercent = Math.min((totalAnswered / questions.length) * 100, 100);
        currentLevelSpan.textContent = totalAnswered + 1;
        progressFill.style.width = Math.max(progressPercent, 1) + "%";
      } else {
        currentLevelSpan.textContent = userState.currentLevel + 1;
        progressFill.style.width = Math.max(((userState.currentLevel + 1) / questions.length * 100), 1) + "%";
      }
    }

    // 初始加载
    updateUserLevelIndicator();
    updateKnowledgeProgress();
    loadQuestion();
  </script>
</body>
</html>