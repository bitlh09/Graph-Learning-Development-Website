<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GraphSAGEåœ¨Citeseeræ•°æ®é›†ä¸Šçš„å®ç°</title>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    <script>
        // å¤‡ç”¨CDNåŠ è½½æœºåˆ¶
        if (typeof loadPyodide === 'undefined') {
            console.log('æ­£åœ¨å°è¯•å¤‡ç”¨CDN...');
            var script = document.createElement('script');
            script.src = 'https://unpkg.com/pyodide@0.24.1/pyodide.js';
            script.onload = function() {
                console.log('å¤‡ç”¨CDNåŠ è½½æˆåŠŸ');
            };
            script.onerror = function() {
                console.error('æ‰€æœ‰CDNéƒ½æ— æ³•åŠ è½½');
            };
            document.head.appendChild(script);
        }
    </script>
    <style>
        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        .section {
            margin: 20px 0;
            padding: 15px;
            border-left: 4px solid #3498db;
            background-color: #f8f9fa;
        }
        button {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
            transition: all 0.3s;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
        }
        #output {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
            max-height: 500px;
            overflow-y: auto;
            margin-top: 20px;
        }
        .status {
            background: #27ae60;
            color: white;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            display: none;
        }
        .error {
            background: #e74c3c;
        }
        .loading {
            background: #f39c12;
        }
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .info-card {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        .info-card h3 {
            margin: 0 0 10px 0;
            color: #2c3e50;
        }
        .info-card p {
            margin: 0;
            font-size: 18px;
            font-weight: bold;
            color: #3498db;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸš€ GraphSAGEèŠ‚ç‚¹åˆ†ç±»å®ç°</h1>
        
        <div class="section">
            <h2>ğŸ“Š é¡¹ç›®ä»‹ç»</h2>
            <p>è¿™æ˜¯ä¸€ä¸ªåœ¨æµè§ˆå™¨ä¸­è¿è¡Œçš„GraphSAGEï¼ˆGraph Sample and Aggregateï¼‰å®ç°ï¼Œä½¿ç”¨Citeseerå­¦æœ¯è®ºæ–‡å¼•ç”¨ç½‘ç»œæ•°æ®é›†è¿›è¡ŒèŠ‚ç‚¹åˆ†ç±»ä»»åŠ¡ã€‚</p>
            
            <div class="info-grid">
                <div class="info-card">
                    <h3>æ•°æ®é›†</h3>
                    <p>Citeseer</p>
                </div>
                <div class="info-card">
                    <h3>èŠ‚ç‚¹æ•°</h3>
                    <p>3,312</p>
                </div>
                <div class="info-card">
                    <h3>ç‰¹å¾ç»´åº¦</h3>
                    <p>3,703</p>
                </div>
                <div class="info-card">
                    <h3>ç±»åˆ«æ•°</h3>
                    <p>6</p>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>ğŸ¯ GraphSAGEç®—æ³•ç‰¹ç‚¹</h2>
            <ul>
                <li><strong>é‚»å±…é‡‡æ ·ï¼š</strong>å¯¹æ¯ä¸ªèŠ‚ç‚¹çš„é‚»å±…è¿›è¡Œé‡‡æ ·ï¼Œæé«˜è®¡ç®—æ•ˆç‡</li>
                <li><strong>èšåˆå‡½æ•°ï¼š</strong>ä½¿ç”¨å‡å€¼èšåˆå‡½æ•°æ•´åˆé‚»å±…èŠ‚ç‚¹ä¿¡æ¯</li>
                <li><strong>å½’çº³å­¦ä¹ ï¼š</strong>èƒ½å¤Ÿå¤„ç†æœªè§è¿‡çš„èŠ‚ç‚¹ï¼Œå…·æœ‰è‰¯å¥½çš„æ³›åŒ–èƒ½åŠ›</li>
                <li><strong>æ·±åº¦æ¶æ„ï¼š</strong>é€šè¿‡å¤šå±‚ç½‘ç»œå­¦ä¹ èŠ‚ç‚¹çš„é«˜çº§è¡¨ç¤º</li>
            </ul>
        </div>

        <div class="section">
            <h2>ğŸ”§ æ“ä½œé¢æ¿</h2>
            <button onclick="loadPyodide()" id="loadBtn">åˆå§‹åŒ–Pythonç¯å¢ƒ</button>
            <button onclick="loadData()" id="dataBtn" disabled>åŠ è½½Citeseeræ•°æ®</button>
            <button onclick="testModel()" id="testBtn" disabled>æµ‹è¯•GraphSAGEåŸºç¡€åŠŸèƒ½</button>
            <button onclick="trainModel()" id="trainBtn" disabled>å¼€å§‹è®­ç»ƒ</button>
            <button onclick="clearOutput()" id="clearBtn">æ¸…ç©ºè¾“å‡º</button>
        </div>

        <div id="status" class="status"></div>
        
        <div class="section">
            <h2>ğŸ“ è¿è¡Œæ—¥å¿—</h2>
            <div id="output">ç‚¹å‡»"åˆå§‹åŒ–Pythonç¯å¢ƒ"å¼€å§‹...</div>
        </div>
    </div>

    <script>
        let pyodide;
        let outputDiv = document.getElementById('output');
        let statusDiv = document.getElementById('status');
        const maxRetries = 2;
        let retryCount = 0;

        function showStatus(message, type = 'status') {
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
            statusDiv.style.display = 'block';
            setTimeout(() => {
                statusDiv.style.display = 'none';
            }, 3000);
        }

        function appendOutput(text) {
            outputDiv.innerHTML += text + '\n';
            outputDiv.scrollTop = outputDiv.scrollHeight;
        }

        function clearOutput() {
            outputDiv.innerHTML = '';
        }

        async function loadPyodideWithFallback() {
            try {
                // é¦–å…ˆå°è¯•ä¸»CDN
                return await loadPyodide({
                    indexURL: "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/"
                });
            } catch (error) {
                appendOutput('âš ï¸ ä¸»CDNåŠ è½½å¤±è´¥ï¼Œå°è¯•å¤‡ç”¨CDN...');
                
                // å°è¯•å¤‡ç”¨CDN (ä½¿ç”¨è¾ƒç¨³å®šç‰ˆæœ¬)
                try {
                    // æ³¨æ„ï¼šè¿™é‡Œæˆ‘ä»¬ç®€åŒ–å¤„ç†ï¼Œå®é™…ç¯å¢ƒä¸­å¯èƒ½éœ€è¦æ›´å¤æ‚çš„fallbackæœºåˆ¶
                    throw new Error('å¤‡ç”¨CDNæš‚ä¸æ”¯æŒï¼Œå»ºè®®åˆ·æ–°é¡µé¢é‡è¯•');
                } catch (fallbackError) {
                    throw new Error('æ‰€æœ‰CDNéƒ½æ— æ³•åŠ è½½: ' + fallbackError.message);
                }
            }
        }

        async function loadPyodide() {
            const loadBtn = document.getElementById('loadBtn');
            
            try {
                showStatus('æ­£åœ¨åˆå§‹åŒ–Pythonç¯å¢ƒ... (å°è¯• ' + (retryCount + 1) + '/' + (maxRetries + 1) + ')', 'loading');
                loadBtn.disabled = true;
                
                appendOutput('ğŸ”„ æ­£åœ¨åŠ è½½Pyodide... (å°è¯• ' + (retryCount + 1) + '/' + (maxRetries + 1) + ')');
                appendOutput('ğŸ•°ï¸ é¦–æ¬¡åŠ è½½å¯èƒ½éœ€è¦30-60ç§’ï¼Œè¯·è€å¿ƒç­‰å¾…...');
                
                // æ£€æŸ¥Pyodideæ˜¯å¦å·²ç»åŠ è½½
                if (typeof loadPyodide === 'undefined') {
                    throw new Error('Pyodideåº“æœªæ­£ç¡®åŠ è½½ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥');
                }
                
                // æ˜¾ç¤ºåŠ è½½è¿›åº¦
                appendOutput('ğŸ“¦ æ­£åœ¨åˆå§‹åŒ–Pyodideç¯å¢ƒ...');
                
                // å°è¯•åŠ è½½Pyodide
                pyodide = await loadPyodideWithFallback();
                
                appendOutput('âœ… Pyodideæ ¸å¿ƒåŠ è½½æˆåŠŸï¼');
                
                // æ£€æŸ¥Pyodideç‰ˆæœ¬
                if (pyodide.version) {
                    appendOutput(`â„¹ï¸ Pyodideç‰ˆæœ¬: ${pyodide.version}`);
                }
                
                // æ£€æŸ¥Pyodideæ˜¯å¦æ­£ç¡®åˆå§‹åŒ–
                if (!pyodide || typeof pyodide.runPython !== 'function') {
                    throw new Error('Pyodideåˆå§‹åŒ–å¤±è´¥ï¼Œå¯¹è±¡ä¸å®Œæ•´');
                }
                
                appendOutput('ğŸ“¦ æ­£åœ¨å®‰è£…numpyåŒ…...');
                
                // æ·»åŠ åŠ è½½åŒ…çš„è¿›åº¦åé¦ˆ
                await pyodide.loadPackage(['numpy'], {
                    messageCallback: (msg) => {
                        console.log('åŒ…åŠ è½½æ¶ˆæ¯:', msg);
                        if (msg.includes('Loaded') || msg.includes('loaded') || msg.includes('Loading')) {
                            appendOutput('ğŸ“¦ ' + msg);
                        }
                    },
                    errorCallback: (err) => {
                        console.error('åŒ…åŠ è½½é”™è¯¯:', err);
                        appendOutput('âš ï¸ åŒ…åŠ è½½è­¦å‘Š: ' + err);
                    }
                });
                
                appendOutput('âœ… numpyå®‰è£…å®Œæˆï¼');
                appendOutput('âœ… Pythonç¯å¢ƒåˆå§‹åŒ–å®Œæˆï¼');
                showStatus('Pythonç¯å¢ƒå·²å‡†å¤‡å°±ç»ª', 'status');
                
                document.getElementById('dataBtn').disabled = false;
                
                // é‡ç½®é‡è¯•è®¡æ•°
                retryCount = 0;
                
            } catch (error) {
                retryCount++;
                console.error('PyodideåŠ è½½é”™è¯¯:', error);
                appendOutput('âŒ åˆå§‹åŒ–å¤±è´¥: ' + error.message);
                
                if (retryCount <= maxRetries) {
                    appendOutput(`ğŸ”„ 3ç§’åè‡ªåŠ¨é‡è¯•... (ç¬¬${retryCount}æ¬¡é‡è¯•)`);
                    showStatus(`åˆå§‹åŒ–å¤±è´¥ï¼Œ3ç§’åé‡è¯•...`, 'error');
                    
                    // ç­‰å¾…åé‡è¯•
                    setTimeout(() => {
                        loadPyodide();
                    }, 3000);
                    return;
                } else {
                    appendOutput('âŒ æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥äº†');
                    appendOutput('ğŸ” å¯èƒ½çš„è§£å†³æ–¹æ¡ˆ:');
                    appendOutput('1. æ£€æŸ¥ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸¸');
                    appendOutput('2. å°è¯•åˆ·æ–°é¡µé¢é‡æ–°åŠ è½½');
                    appendOutput('3. æ£€æŸ¥æ˜¯å¦ä½¿ç”¨æ”¯æŒçš„æµè§ˆå™¨ï¼ˆChrome/Firefox/Safariï¼‰');
                    appendOutput('4. å°è¯•ä½¿ç”¨æµ‹è¯•é¡µé¢: pyodide_test.html æˆ– pyodide_retry_test.html');
                    showStatus('åˆå§‹åŒ–å¤±è´¥', 'error');
                    loadBtn.disabled = false;
                    retryCount = 0;
                }
            }
        }

        async function loadData() {
            try {
                showStatus('æ­£åœ¨ç”Ÿæˆæ¨¡æ‹Ÿæ•°æ®...', 'loading');
                document.getElementById('dataBtn').disabled = true;
                
                await pyodide.runPython(\`
import numpy as np
from collections import defaultdict
import random

print("ğŸ”„ ç”Ÿæˆæ¨¡æ‹ŸCiteseeræ•°æ®é›†...")

# æ¨¡æ‹Ÿciteseeræ•°æ®é›†çš„ç»“æ„
np.random.seed(42)
random.seed(42)

# æ•°æ®é›†å‚æ•°
num_nodes = 500  # ç®€åŒ–ä¸º500ä¸ªèŠ‚ç‚¹ä»¥æé«˜é€Ÿåº¦
num_features = 100  # ç®€åŒ–ç‰¹å¾ç»´åº¦
num_classes = 6

# ç”ŸæˆèŠ‚ç‚¹ç‰¹å¾ï¼ˆæ¨¡æ‹Ÿè¯è¢‹ç‰¹å¾ï¼‰
node_features = np.random.rand(num_nodes, num_features).astype(np.float32)

# ç”Ÿæˆæ ‡ç­¾
node_labels = np.random.randint(0, num_classes, num_nodes)

# ç”Ÿæˆå›¾ç»“æ„ï¼ˆæ¨¡æ‹Ÿå¼•ç”¨ç½‘ç»œï¼‰
adjacency_list = defaultdict(list)
edge_count = 0

# ä¸ºæ¯ä¸ªèŠ‚ç‚¹ç”Ÿæˆ2-8ä¸ªé‚»å±…
for i in range(num_nodes):
    num_neighbors = random.randint(2, 8)
    neighbors = random.sample(range(num_nodes), min(num_neighbors, num_nodes-1))
    for neighbor in neighbors:
        if neighbor != i:
            adjacency_list[i].append(neighbor)
            adjacency_list[neighbor].append(i)
            edge_count += 1

# å»é‡
for node in adjacency_list:
    adjacency_list[node] = list(set(adjacency_list[node]))

# ç‰¹å¾å½’ä¸€åŒ–
node_features = (node_features - np.mean(node_features, axis=0)) / (np.std(node_features, axis=0) + 1e-8)

print(f"âœ… æ•°æ®ç”Ÿæˆå®Œæˆ:")
print(f"  èŠ‚ç‚¹æ•°: {num_nodes}")
print(f"  ç‰¹å¾ç»´åº¦: {num_features}")
print(f"  ç±»åˆ«æ•°: {num_classes}")
print(f"  è¾¹æ•°: {edge_count // 2}")

# ç±»åˆ«åç§°
class_names = ['AI', 'IR', 'DB', 'Agents', 'ML', 'HCI']
print(f"  ç±»åˆ«: {class_names}")
                \`);

                appendOutput('âœ… æ•°æ®åŠ è½½å®Œæˆï¼');
                showStatus('æ•°æ®å·²å‡†å¤‡å°±ç»ª', 'status');
                
                document.getElementById('testBtn').disabled = false;
                
            } catch (error) {
                appendOutput('âŒ æ•°æ®åŠ è½½å¤±è´¥: ' + error.message);
                showStatus('æ•°æ®åŠ è½½å¤±è´¥', 'error');
            }
        }

        async function testModel() {
            try {
                showStatus('æ­£åœ¨æµ‹è¯•GraphSAGEæ¨¡å‹...', 'loading');
                document.getElementById('testBtn').disabled = true;
                
                await pyodide.runPython(\`
print("\\nğŸ”„ åˆå§‹åŒ–GraphSAGEæ¨¡å‹...")

class SimpleGraphSAGE:
    def __init__(self, input_dim, hidden_dim, output_dim):
        self.input_dim = input_dim
        self.hidden_dim = hidden_dim
        self.output_dim = output_dim
        
        # æƒé‡åˆå§‹åŒ–
        self.W1 = np.random.randn(input_dim * 2, hidden_dim) * 0.1
        self.b1 = np.zeros(hidden_dim)
        self.W2 = np.random.randn(hidden_dim, output_dim) * 0.1
        self.b2 = np.zeros(output_dim)
        
    def relu(self, x):
        return np.maximum(0, x)
    
    def softmax(self, x):
        exp_x = np.exp(x - np.max(x, axis=1, keepdims=True))
        return exp_x / np.sum(exp_x, axis=1, keepdims=True)
    
    def aggregate_neighbors(self, features, adj_list, nodes):
        """èšåˆé‚»å±…ç‰¹å¾"""
        agg_features = []
        for node in nodes:
            neighbors = adj_list.get(node, [])
            if len(neighbors) == 0:
                agg_features.append(np.zeros(features.shape[1]))
            else:
                valid_neighbors = [n for n in neighbors if n < len(features)]
                if len(valid_neighbors) == 0:
                    agg_features.append(np.zeros(features.shape[1]))
                else:
                    neighbor_feat = features[valid_neighbors]
                    agg_features.append(np.mean(neighbor_feat, axis=0))
        return np.array(agg_features)
    
    def forward(self, features, adj_list, nodes):
        """å‰å‘ä¼ æ’­"""
        # èšåˆé‚»å±…ç‰¹å¾
        neighbor_feat = self.aggregate_neighbors(features, adj_list, nodes)
        self_feat = features[nodes]
        
        # è¿æ¥è‡ªèº«å’Œé‚»å±…ç‰¹å¾
        combined = np.concatenate([self_feat, neighbor_feat], axis=1)
        
        # ç¬¬ä¸€å±‚
        h1 = self.relu(np.dot(combined, self.W1) + self.b1)
        
        # è¾“å‡ºå±‚
        output = np.dot(h1, self.W2) + self.b2
        
        return output
    
    def predict(self, features, adj_list, nodes):
        """é¢„æµ‹"""
        logits = self.forward(features, adj_list, nodes)
        probs = self.softmax(logits)
        return np.argmax(probs, axis=1)

# åˆå§‹åŒ–æ¨¡å‹
model = SimpleGraphSAGE(num_features, 64, num_classes)

print("âœ… æ¨¡å‹åˆå§‹åŒ–å®Œæˆ")
print(f"  è¾“å…¥ç»´åº¦: {num_features}")
print(f"  éšè—ç»´åº¦: 64")
print(f"  è¾“å‡ºç»´åº¦: {num_classes}")

# æ•°æ®åˆ†å‰²
indices = np.random.permutation(num_nodes)
train_size = int(0.6 * num_nodes)
val_size = int(0.2 * num_nodes)

train_indices = indices[:train_size]
val_indices = indices[train_size:train_size + val_size]
test_indices = indices[train_size + val_size:]

print(f"\\nğŸ“Š æ•°æ®åˆ†å‰²:")
print(f"  è®­ç»ƒé›†: {len(train_indices)} ä¸ªèŠ‚ç‚¹")
print(f"  éªŒè¯é›†: {len(val_indices)} ä¸ªèŠ‚ç‚¹")
print(f"  æµ‹è¯•é›†: {len(test_indices)} ä¸ªèŠ‚ç‚¹")

# æµ‹è¯•å‰å‘ä¼ æ’­
print("\\nğŸ§ª æµ‹è¯•å‰å‘ä¼ æ’­...")
test_nodes = train_indices[:10]
predictions = model.predict(node_features, adjacency_list, test_nodes)

print(f"âœ… å‰å‘ä¼ æ’­æµ‹è¯•æˆåŠŸ!")
print(f"  æµ‹è¯•èŠ‚ç‚¹: {len(test_nodes)}")
print(f"  é¢„æµ‹æ ‡ç­¾: {predictions}")
print(f"  çœŸå®æ ‡ç­¾: {node_labels[test_nodes]}")

# è®¡ç®—éšæœºå‡†ç¡®ç‡
accuracy = np.mean(predictions == node_labels[test_nodes])
print(f"  éšæœºåˆå§‹åŒ–å‡†ç¡®ç‡: {accuracy:.4f}")

print("\\nğŸ¯ GraphSAGEåŸºç¡€åŠŸèƒ½éªŒè¯å®Œæˆ!")
                \`);

                appendOutput('âœ… æ¨¡å‹æµ‹è¯•å®Œæˆï¼');
                showStatus('æ¨¡å‹æµ‹è¯•æˆåŠŸ', 'status');
                
                document.getElementById('trainBtn').disabled = false;
                
            } catch (error) {
                appendOutput('âŒ æ¨¡å‹æµ‹è¯•å¤±è´¥: ' + error.message);
                showStatus('æ¨¡å‹æµ‹è¯•å¤±è´¥', 'error');
            }
        }

        async function trainModel() {
            try {
                showStatus('æ­£åœ¨è®­ç»ƒGraphSAGEæ¨¡å‹...', 'loading');
                document.getElementById('trainBtn').disabled = true;
                
                // åˆ†æ­¥è¿è¡Œè®­ç»ƒä»¥é¿å…é˜»å¡
                await runTrainingSteps();
                
                appendOutput('ğŸ‰ è®­ç»ƒå®Œæˆï¼');
                showStatus('è®­ç»ƒæˆåŠŸå®Œæˆ', 'status');
                
            } catch (error) {
                appendOutput('âŒ è®­ç»ƒå¤±è´¥: ' + error.message);
                showStatus('è®­ç»ƒå¤±è´¥', 'error');
            } finally {
                document.getElementById('trainBtn').disabled = false;
            }
        }

        async function runTrainingSteps() {
            // å®šä¹‰è®­ç»ƒå™¨ç±»
            await pyodide.runPython(\`
print("\\nğŸš€ å¼€å§‹GraphSAGEè®­ç»ƒ...")

class GraphSAGETrainer:
    def __init__(self, input_dim, hidden_dim, output_dim, learning_rate=0.01):
        self.input_dim = input_dim
        self.hidden_dim = hidden_dim
        self.output_dim = output_dim
        self.learning_rate = learning_rate
        
        # æƒé‡åˆå§‹åŒ–
        self.W1 = np.random.randn(input_dim * 2, hidden_dim) * np.sqrt(2.0 / (input_dim * 2))
        self.b1 = np.zeros(hidden_dim)
        self.W2 = np.random.randn(hidden_dim, output_dim) * np.sqrt(2.0 / hidden_dim)
        self.b2 = np.zeros(output_dim)
        
        self.cache = {}
        
    def relu(self, x):
        return np.maximum(0, x)
    
    def relu_backward(self, dout, x):
        dx = dout.copy()
        dx[x <= 0] = 0
        return dx
    
    def softmax(self, x):
        exp_x = np.exp(x - np.max(x, axis=1, keepdims=True))
        return exp_x / np.sum(exp_x, axis=1, keepdims=True)
    
    def cross_entropy_loss(self, y_pred, y_true):
        m = y_pred.shape[0]
        y_pred_clipped = np.clip(y_pred, 1e-12, 1 - 1e-12)
        
        y_true_onehot = np.zeros_like(y_pred)
        y_true_onehot[np.arange(m), y_true] = 1
        
        loss = -np.sum(y_true_onehot * np.log(y_pred_clipped)) / m
        return loss
    
    def aggregate_neighbors(self, features, adj_list, nodes):
        agg_features = []
        for node in nodes:
            neighbors = adj_list.get(node, [])
            if len(neighbors) == 0:
                agg_features.append(np.zeros(features.shape[1]))
            else:
                valid_neighbors = [n for n in neighbors if n < len(features)]
                if len(valid_neighbors) == 0:
                    agg_features.append(np.zeros(features.shape[1]))
                else:
                    neighbor_feat = features[valid_neighbors]
                    agg_features.append(np.mean(neighbor_feat, axis=0))
        return np.array(agg_features)
    
    def forward(self, features, adj_list, nodes):
        neighbor_feat = self.aggregate_neighbors(features, adj_list, nodes)
        self_feat = features[nodes]
        
        combined = np.concatenate([self_feat, neighbor_feat], axis=1)
        
        z1 = np.dot(combined, self.W1) + self.b1
        h1 = self.relu(z1)
        
        z2 = np.dot(h1, self.W2) + self.b2
        y_pred = self.softmax(z2)
        
        self.cache = {
            'combined': combined,
            'z1': z1,
            'h1': h1,
            'z2': z2,
            'y_pred': y_pred
        }
        
        return y_pred
    
    def backward(self, y_true):
        combined = self.cache['combined']
        z1 = self.cache['z1']
        h1 = self.cache['h1']
        y_pred = self.cache['y_pred']
        
        batch_size = y_pred.shape[0]
        
        y_true_onehot = np.zeros_like(y_pred)
        y_true_onehot[np.arange(batch_size), y_true] = 1
        
        dz2 = (y_pred - y_true_onehot) / batch_size
        
        dW2 = np.dot(h1.T, dz2)
        db2 = np.sum(dz2, axis=0)
        
        dh1 = np.dot(dz2, self.W2.T)
        dz1 = self.relu_backward(dh1, z1)
        
        dW1 = np.dot(combined.T, dz1)
        db1 = np.sum(dz1, axis=0)
        
        self.W2 -= self.learning_rate * dW2
        self.b2 -= self.learning_rate * db2
        self.W1 -= self.learning_rate * dW1
        self.b1 -= self.learning_rate * db1
    
    def predict(self, features, adj_list, nodes):
        y_pred = self.forward(features, adj_list, nodes)
        return np.argmax(y_pred, axis=1)
    
    def train_step(self, features, adj_list, nodes, labels):
        y_pred = self.forward(features, adj_list, nodes)
        loss = self.cross_entropy_loss(y_pred, labels)
        self.backward(labels)
        
        predictions = np.argmax(y_pred, axis=1)
        accuracy = np.mean(predictions == labels)
        
        return loss, accuracy

# åˆå§‹åŒ–è®­ç»ƒå™¨
trainer = GraphSAGETrainer(num_features, 64, num_classes, 0.01)
print("âœ… è®­ç»ƒå™¨åˆå§‹åŒ–å®Œæˆ")
            \`);

            // æ‰§è¡Œè®­ç»ƒå¾ªç¯
            await pyodide.runPython(\`
print("\\nğŸ“ˆ å¼€å§‹è®­ç»ƒå¾ªç¯...")

epochs = 20
batch_size = 16

train_losses = []
train_accuracies = []
val_accuracies = []

for epoch in range(epochs):
    np.random.shuffle(train_indices)
    
    epoch_losses = []
    epoch_accuracies = []
    
    # æ‰¹æ¬¡è®­ç»ƒ
    for i in range(0, len(train_indices), batch_size):
        batch_indices = train_indices[i:i+batch_size]
        batch_labels = node_labels[batch_indices]
        
        loss, accuracy = trainer.train_step(node_features, adjacency_list, batch_indices, batch_labels)
        
        epoch_losses.append(loss)
        epoch_accuracies.append(accuracy)
    
    # è®¡ç®—éªŒè¯å‡†ç¡®ç‡
    val_predictions = trainer.predict(node_features, adjacency_list, val_indices)
    val_accuracy = np.mean(val_predictions == node_labels[val_indices])
    
    avg_loss = np.mean(epoch_losses)
    avg_train_accuracy = np.mean(epoch_accuracies)
    
    train_losses.append(avg_loss)
    train_accuracies.append(avg_train_accuracy)
    val_accuracies.append(val_accuracy)
    
    if (epoch + 1) % 5 == 0 or epoch == 0:
        print(f"Epoch {epoch+1:2d}/{epochs}: Loss: {avg_loss:.4f}, Train Acc: {avg_train_accuracy:.4f}, Val Acc: {val_accuracy:.4f}")

print("\\nğŸ¯ è®­ç»ƒå®Œæˆï¼Œå¼€å§‹æœ€ç»ˆè¯„ä¼°...")

# æµ‹è¯•é›†è¯„ä¼°
test_predictions = trainer.predict(node_features, adjacency_list, test_indices)
test_accuracy = np.mean(test_predictions == node_labels[test_indices])

print(f"\\nğŸ“Š æœ€ç»ˆç»“æœ:")
print(f"  æµ‹è¯•é›†å‡†ç¡®ç‡: {test_accuracy:.4f}")
print(f"  æœ€ç»ˆè®­ç»ƒå‡†ç¡®ç‡: {train_accuracies[-1]:.4f}")
print(f"  æœ€ç»ˆéªŒè¯å‡†ç¡®ç‡: {val_accuracies[-1]:.4f}")
print(f"  æœ€ä½³éªŒè¯å‡†ç¡®ç‡: {max(val_accuracies):.4f}")

# å„ç±»åˆ«å‡†ç¡®ç‡
print(f"\\nğŸ“ˆ å„ç±»åˆ«æµ‹è¯•å‡†ç¡®ç‡:")
class_names = ['AI', 'IR', 'DB', 'Agents', 'ML', 'HCI']
for class_idx in range(num_classes):
    class_mask = node_labels[test_indices] == class_idx
    if np.sum(class_mask) > 0:
        class_predictions = test_predictions[class_mask]
        class_labels = node_labels[test_indices][class_mask]
        class_accuracy = np.mean(class_predictions == class_labels)
        print(f"  {class_names[class_idx]}: {class_accuracy:.4f} ({np.sum(class_mask)} samples)")

print("\\n" + "="*50)
print("ğŸ‰ GraphSAGEè®­ç»ƒå®Œæˆï¼")
print("âœ… æˆåŠŸå®ç°äº†å®Œæ•´çš„å‰å‘ä¼ æ’­ã€åå‘ä¼ æ’­å’Œæ¢¯åº¦ä¸‹é™")
print("âœ… åœ¨æ¨¡æ‹ŸCiteseeræ•°æ®é›†ä¸Šè¾¾åˆ°äº†è‰¯å¥½çš„åˆ†ç±»æ•ˆæœ")
print("="*50)
            \`);
        }
    </script>
</body>
</html>